<!DOCTYPE html>
<html lang="en" style="height:100%">
	<head>
		<title>Myocardium WebGL Demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>			
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
		<link rel="stylesheet" href="styles/my_styles.css">
		<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
		<script>
	    	var dojoConfig = {
				async: true,
				// This code registers the correct location of the "demo" package
				// so we can load Dojo from the CDN whilst still being able to
				// load local modules
				packages: [{
					name: "js",
					location: location.pathname.replace(/\/[^/]+$/, '')  + '/js'
				}]
			};
    	</script>
    	<script src="http://ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js" data-dojo-config="async: 1, parseOnLoad: true" ></script>
		<script>require(["dijit/Dialog"]);</script>
	</head>

	<body style="height:100%;">
		<div style="position:absolute;height:100%;width:100%">
			<div id="displayPort" style="position:absolute;height:100%;width:50%;left:0%;border-right: 1px solid #000000;">
				<div class="row">
					<div class="col-sm-3">
					</div>
					<div class="col-sm-1">
						<div id="playToggle" class="play" onclick="triggerAnimation()"></div>
					</div>	
					<div class="col-sm-4">
					<input id="mySlider" type="range" min="0" max="100" value ="0" step="1" oninput="sliderChanged(this.value)" style="height: 64px;width:100%;"/>
					</div>
					<div class="col-sm-4">
					</div>
				</div>
				
				
				<!-- Rounded switch -->
				
				<label class="switch">
				  <div class ="switch_text"> Heart </div>
				  <input type="checkbox" checked onclick='toggleModelDisplay(this);' value="heart">
				  <span class="switchSlider round"></span>
				</label>
				
				<label class="switch">
				  <div class ="switch_text"> Ventricles </div>
				  <input type="checkbox" checked onclick='toggleModelDisplay(this);' value="ventricles">
				  <span class="switchSlider round"></span>
				</label>
				
				<label class="switch">
				  <div class ="switch_text"> Nerves </div>
				  <input type="checkbox" checked onclick='toggleModelDisplay(this);' value="nerves">
				  <span class="switchSlider round"></span>
				</label>
				
				
				<label class="switch">
				  <div class ="switch_text"> Points </div>
				  <input type="checkbox" checked onclick='toggleModelDisplay(this);' value="terminal">
				  <span class="switchSlider round"></span>
				</label>
				
				<div id="tooltipcontainer">
					<div class="tooltip" id="tip">
		  				<span class="tooltiptext" id="tiptext"> Tooltip text</span>
					</div>
				</div>
				
			</div>
			<div id="referenceDisplayPort" style="position:absolute;height:100%;width:50%;left:50%;top:0%;">
				<p style="text-align: center;">&nbsp;</p>
				<p style="text-align: center;">&nbsp;</p>
				<p style="text-align: center;" id="text_display" ><strong>You have not selected a node yet.</strong></p>
			</div>
		</div>
		<div data-dojo-type="dijit/Dialog" data-dojo-id="cellDialog" style="background-color:#FFF;border: 1px solid #000000;">
			<p style="text-align: center;">&nbsp;</p>
			<strong>You selected cell model 1. Open this model in:</strong>
			<p style="text-align: center;">&nbsp;</p>
			<div style="width:90%;height:99%;left:5%;bottom:1%;">
				<a target="_blank" href = "https://models.physiomeproject.org/exposure/d5d6bff87af2bc1e94b6e8706227ba1a">
					<img src="images/logo-cellml.png" style="width:100%;">
				</a>
			</div>
		</div>

		<script src="js/three.min.js"></script>
		<script src="js/zinc_threejs_control.js"></script>
		<script src="js/zinc_3js_renderer.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<link rel="stylesheet" type="text/css" href="styles/dat-gui-swec.css">
		<script src="./js/OrbitControls.js"></script>
		<script src="js/volume_render.js"></script>
		<script id="fragmentShaderFirstPass" type="x-shader/x-fragment">
			varying vec3 worldSpaceCoords;
			
			void main()
			{	
				//The fragment's world space coordinates as fragment output.
				gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1 );
			}
		</script>
		<script id="vertexShaderFirstPass" type="x-shader/x-vertex">
			varying vec3 worldSpaceCoords;
			uniform float min_x;
			uniform float max_x;
			uniform float min_y;
			uniform float max_y;
			uniform float min_z;
			uniform float max_z;
			
			void main()
			{
				worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]
				if (worldSpaceCoords.x > max_x)
				{
					worldSpaceCoords.x = max_x;
				}
				if (worldSpaceCoords.x < min_x)
				{
					worldSpaceCoords.x = min_x;
				}
				
				if (worldSpaceCoords.y > max_y)
				{
					worldSpaceCoords.y = max_y;
				}
				if (worldSpaceCoords.y < min_y)				
				{
					worldSpaceCoords.y = min_y;
				}
				
				if (worldSpaceCoords.z > max_z)
				{
					worldSpaceCoords.z = max_z;
				}
				if (worldSpaceCoords.z < min_z)
				{
					worldSpaceCoords.z = min_z;
				}		
						
				//Set the world space coordinates of the back faces vertices as output.
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4( (worldSpaceCoords - vec3(0.5, 0.5, 0.5)), 1.0 );
			}
		</script>
		<script id="fragmentShaderSecondPass" type="x-shader/x-fragment">
			varying vec3 worldSpaceCoords;
			varying vec4 projectedCoords;
			uniform sampler2D tex, cubeTex;
			uniform float steps;
			uniform float alphaCorrection;
			uniform bool black_flip;
			// The maximum distance through our rendering volume is sqrt(3).
			// The maximum number of steps we take to travel a distance of 1 is 512.
			// ceil( sqrt(3) * 512 ) = 887
			// This prevents the back of the image from getting cut off when steps=512 & viewing diagonally.
			const int MAX_STEPS = 887;
			
			//Acts like a texture3D using Z slices and trilinear filtering.
			vec4 sampleAs3DTexture( vec3 texCoord )
			{
				vec4 colorSlice1, colorSlice2;
				vec2 texCoordSlice1, texCoordSlice2;

				//The z coordinate determines which Z slice we have to look for.
				//Z slice number goes from 0 to 255.
				float zSliceNumber1 = floor(texCoord.z  * 255.0);

				//As we use trilinear we go the next Z slice.
				float zSliceNumber2 = min( zSliceNumber1 + 1.0, 255.0); //Clamp to 255

				//The Z slices are stored in a matrix of 16x16 of Z slices.
				//The original UV coordinates have to be rescaled by the tile numbers in each row and column.
				texCoord.xy /= 16.0;

				texCoordSlice1 = texCoordSlice2 = texCoord.xy;

				//Add an offset to the original UV coordinates depending on the row and column number.
				texCoordSlice1.x += (mod(zSliceNumber1, 16.0 ) / 16.0);
				texCoordSlice1.y += floor((255.0 - zSliceNumber1) / 16.0) / 16.0;

				texCoordSlice2.x += (mod(zSliceNumber2, 16.0 ) / 16.0);
				texCoordSlice2.y += floor((255.0 - zSliceNumber2) / 16.0) / 16.0;

				colorSlice1 = texture2D( cubeTex, texCoordSlice1 );
				colorSlice2 = texture2D( cubeTex, texCoordSlice2 );
				colorSlice1.a = (colorSlice1.r + colorSlice1.g + colorSlice1.b) / 3.0;
				colorSlice2.a = (colorSlice2.r + colorSlice2.g + colorSlice2.b) / 3.0;

				//How distant is zSlice1 to ZSlice2. Used to interpolate between one Z slice and the other.
				float zDifference = mod(texCoord.z * 255.0, 1.0);

				//Finally interpolate between the two intermediate colors of each Z slice.
				return mix(colorSlice1, colorSlice2, zDifference) ;
			}


			void main( void ) {
				

				//Transform the coordinates it from [-1;1] to [0;1]
				vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,
								((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0 );

				//The back position is the world space position stored in the texture.
				vec3 backPos = texture2D(tex, texc).xyz;

				//The front position is the world space position of the second render pass.
				vec3 frontPos = worldSpaceCoords;

				//The direction from the front position to back position.
				vec3 dir = backPos - frontPos;

				float rayLength = length(dir);

				//Calculate how long to increment in each step.
				float delta = 1.0 / steps;

				//The increment in each direction for each step.
				vec3 deltaDirection = normalize(dir) * delta;
				float deltaDirectionLength = length(deltaDirection);

				//Start the ray casting from the front position.
				vec3 currentPosition = frontPos;

				//The color accumulator.
				vec4 accumulatedColor = vec4(0.0);

				//The alpha value accumulated so far.
				float accumulatedAlpha = 0.0;

				//How long has the ray travelled so far.
				float accumulatedLength = 0.0;

				//If we have twice as many samples, we only need ~1/2 the alpha per sample.
				//Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.
				float alphaScaleFactor = 25.6 * delta;

				vec4 colorSample;
				float alphaSample;

				//Perform the ray marching iterations
				for(int i = 0; i < MAX_STEPS; i++)
				{
					//Get the voxel intensity value from the 3D texture.
					colorSample = sampleAs3DTexture( currentPosition );

					//Allow the alpha correction customization.
					alphaSample = colorSample.a * alphaCorrection;

					//Applying this effect to both the color and alpha accumulation results in more realistic transparency.
					alphaSample *= (1.0 - accumulatedAlpha);

					//Scaling alpha by the number of steps makes the final color invariant to the step size.
					alphaSample *= alphaScaleFactor;

					//Perform the composition.
					accumulatedColor += colorSample * alphaSample;

					//Store the alpha accumulated so far.
					accumulatedAlpha += alphaSample;

					//Advance the ray.
					currentPosition += deltaDirection;
					accumulatedLength += deltaDirectionLength;

					//If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.
					if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )
						break;
				}

				gl_FragColor  = accumulatedColor;
				gl_FragColor.a = 1.0;
				if (black_flip)
				{
					if (gl_FragColor.r < 0.05) 
					{
						if (gl_FragColor.g < 0.05) 
						{
							if (gl_FragColor.b < 0.05) 
							{
								gl_FragColor.r = 1.0;
								gl_FragColor.g = 1.0;
								gl_FragColor.b = 1.0;
								gl_FragColor.a = 0.0;
							}
						}
					}
				}
			}
		</script>

		<script id="vertexShaderSecondPass" type="x-shader/x-vertex">
			varying vec3 worldSpaceCoords;
			varying vec4 projectedCoords;
			uniform float min_x;
			uniform float max_x;
			uniform float min_y;
			uniform float max_y;
			uniform float min_z;
			uniform float max_z;
			
			void main()
			{
				vec3 originalCoords = position + vec3(0.5, 0.5,0.5);
				if (originalCoords.x > max_x)
				{
					originalCoords.x = max_x;
				}
				if (originalCoords.x < min_x)
				{
					originalCoords.x = min_x;
				}
				if (originalCoords.y > max_y)
				{
					originalCoords.y = max_y;
				}
				if (originalCoords.y < min_y)				
				{
					originalCoords.y = min_y;
				}	
				if (originalCoords.z > max_z)
				{
					originalCoords.z = max_z;
				}
				if (originalCoords.z < min_z)
				{
					originalCoords.z = min_z;
				}		

				worldSpaceCoords = (modelMatrix * vec4(originalCoords, 1.0 )).xyz;
				gl_Position = projectionMatrix *  modelViewMatrix * vec4((originalCoords - vec3(0.5, 0.5, 0.5)), 1.0 );
				projectedCoords =  projectionMatrix * modelViewMatrix * vec4((originalCoords - vec3(0.5, 0.5, 0.5)), 1.0 );
			}
		</script>
		
		
		<script>
			var currentModel = undefined;
		
			var zincRenderer = undefined;
			var referenceRenderer = undefined;
			var currentHoverId = -1;
			var tooltipcontainerElement = document.getElementById('tooltipcontainer');
			var tipElement = document.getElementById('tip');
			var tiptextElement = document.getElementById('tiptext');
			var pickerScene = undefined;
			var displayScene = undefined;
			var windowWidth, windowHeight;
			
			
			function setupRenderer(elementID) {
				var localContainer = document.createElement( 'div' );
				document.getElementById(elementID).appendChild( localContainer );
				localContainer.style.height = "100%"
				var localRenderer = new Zinc.Renderer(localContainer, window);
				Zinc.defaultMaterialColor = 0xFFFF9C
				localRenderer.initialiseVisualisation();
				localRenderer.playAnimation = false;	
				return localRenderer;
			}
			
			function geometryToggle(name, flag) {
				return function(zincGeometry) {
					if (zincGeometry.groupName && zincGeometry.groupName.includes(name)) {
						zincGeometry.setVisibility(flag);
					}
				}
			}
				
			function toggleModelDisplay(callbackElement) {
				console.log(callbackElement.value);
				if (callbackElement.value == "terminal") {
					displayScene.forEachGlyphset(geometryToggle(callbackElement.value, callbackElement.checked));
					pickerScene.forEachGlyphset(geometryToggle(callbackElement.value, callbackElement.checked));
				} else {
					displayScene.forEachGeometry(geometryToggle(callbackElement.value, callbackElement.checked));
				}
			}
				
			function getPos(el) {
			    for (var lx=0, ly=0;
         			el != null;
         			lx += el.offsetLeft, ly += el.offsetTop, el = el.offsetParent);
    			return {x: lx,y: ly};
			}
		
		    function sliderChanged(slideAmount) {
				pickerScene.setMorphsTime(slideAmount * 30);
				displayScene.setMorphsTime(slideAmount * 30);
    		}

			var showTooltip = function(id, x, y) {
				if (currentHoverId != id) {
					tiptextElement.innerHTML = "Node " + id;
					var pos = getPos(document.getElementById("displayPort"));
					tooltipcontainerElement.style.left = x - pos.x +"px";
					tooltipcontainerElement.style.top = (y - 20) - pos.y + "px";
					tipElement.style.visibility = "visible";
					tipElement.style.opacity = 1;
					tiptextElement.style.visibility = "visible";
					tiptextElement.style.opacity = 1;
					currentHoverId = id;

				}
			}
			
			var hideTooltip = function() {
				currentHoverId = -1;
				tipElement.style.visibility = "hidden";
				tipElement.style.opacity = 0;
				tiptextElement.style.visibility = "hidden";
				tiptextElement.style.opacity = 0;
			}
			
			var setString = function(id) {
			 	var text_display = document.getElementById('text_display');
 				text_display.innerHTML = "<strong>You have selected node number: <span style='color:#FF4444'>" + id + "</span>.</strong>";
			}
			
			var _pickingCallback = function() {
				return function(intersects, window_x, window_y) {
					if (intersects[0] !== undefined) {
						var id = Math.round(intersects[ 0 ].object.material.color.b * 255) ;
						showTooltip(id, window_x, window_y);
						setString(id);
						makeCollagenVisible();
					}
				}	
			};
			
			var _hoverCallback = function() {
				return function(intersects, window_x, window_y) {
					if (intersects[0] !== undefined) {
						var id = Math.round(intersects[ 0 ].object.material.color.b * 255) ;
						document.getElementById("displayPort").style.cursor = "pointer";
						showTooltip(id, window_x, window_y);
					}
					else {
						hideTooltip();
						document.getElementById("displayPort").style.cursor = "auto";
					}
				}	
			};
													
			
			function loadMain() {
				var scene = zincRenderer.getCurrentScene();
				scene.loadViewURL("animated/heart_view.json");
				scene.loadMetadataURL("animated/animated_nerve_1.json");
				displayScene=scene;
				var directionalLight = scene.directionalLight;
				directionalLight.intensity = 1.4;
				pickerScene = zincRenderer.createScene("picker_scene");
				pickerScene.loadMetadataURL("animated/picking_node_1.json");
				var zincCameraControl = scene.getZincCameraControls();
				zincCameraControl.enableRaycaster(pickerScene, _pickingCallback(), _hoverCallback());	
			}					
			
			var triggerAnimation = function() {
				var playElement = document.getElementById("playToggle");
					if (playElement.className == "play") {
						playElement.className = "pause";
						zincRenderer.playAnimation = true;
					} else {
						playElement.className = "play";
						zincRenderer.playAnimation = false;
					}
			}

			
			function resetView()
			{
				zincRenderer.resetView();
			}
			
			function viewAll()
			{
				zincRenderer.viewAll();
			}
			
			
			var updateTimeSlider = function() {
				return function() {
					if (zincRenderer.playAnimation == true)	{
						var currentTime = zincRenderer.getCurrentTime();
						var sliderElement = document.getElementById("mySlider");
						var sliderValue = currentTime / 30.0;
						sliderElement.value = sliderValue;
						pickerScene.setMorphsTime(currentTime);
					}
				}	
			}
			
			zincRenderer = setupRenderer("displayPort");
			loadMain();
			
			zincRenderer.addPreRenderCallbackFunction(updateTimeSlider());
			zincRenderer.animate();
			
			volumeRenderInit();
			volumeRenderAnimate();

		</script>

	</body>
</html>
